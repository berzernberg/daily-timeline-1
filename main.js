/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DailyNotesTimelinePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// timeline-view.ts
var import_obsidian = require("obsidian");
var VIEW_TYPE_TIMELINE = "daily-notes-timeline";
var ZOOM_CONFIG = {
  MIN: 0.7,
  MAX: 10,
  DEFAULT: 1,
  STEP: 0.5,
  BASE_SEGMENT_WIDTH: 200
};
var TimelineView = class extends import_obsidian.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    __publicField(this, "plugin");
    __publicField(this, "contentEl");
    __publicField(this, "startDate");
    __publicField(this, "endDate");
    __publicField(this, "tooltips", []);
    __publicField(this, "zoomLevel", ZOOM_CONFIG.DEFAULT);
    __publicField(this, "timelineScrollEl", null);
    __publicField(this, "timelineContainerEl", null);
    __publicField(this, "isDragging", false);
    __publicField(this, "dragStartX", 0);
    __publicField(this, "dragStartScrollLeft", 0);
    __publicField(this, "viewMode", "month");
    __publicField(this, "monthSelectEl", null);
    __publicField(this, "quickRangeSelectEl", null);
    __publicField(this, "startDateInputEl", null);
    __publicField(this, "endDateInputEl", null);
    __publicField(this, "customRangeContainerEl", null);
    __publicField(this, "zoomSlider", null);
    __publicField(this, "zoomLabel", null);
    this.plugin = plugin;
    this.viewMode = this.plugin.settings.viewMode;
    const now = /* @__PURE__ */ new Date();
    if (this.viewMode === "custom" && this.plugin.settings.customStartDate && this.plugin.settings.customEndDate) {
      this.startDate = this.parseStoredDate(this.plugin.settings.customStartDate);
      this.endDate = this.parseStoredDate(this.plugin.settings.customEndDate);
    } else {
      this.startDate = new Date(now.getFullYear(), now.getMonth(), 1);
      this.endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
    }
  }
  parseStoredDate(dateStr) {
    const [year, month, day] = dateStr.split("-").map(Number);
    return new Date(year, month - 1, day);
  }
  formatDateForStorage(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  }
  formatDateForInput(date) {
    return this.formatDateForStorage(date);
  }
  getRangeDurationInDays() {
    const diffTime = Math.abs(this.endDate.getTime() - this.startDate.getTime());
    return Math.ceil(diffTime / (1e3 * 60 * 60 * 24)) + 1;
  }
  getViewType() {
    return VIEW_TYPE_TIMELINE;
  }
  getDisplayText() {
    return "Daily Notes Timeline";
  }
  getIcon() {
    return "calendar-clock";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("timeline-view-container");
    this.contentEl = container.createDiv({ cls: "timeline-content" });
    await this.renderControls();
    await this.renderTimeline();
  }
  async onClose() {
    this.cleanupTooltips();
    this.contentEl.empty();
  }
  cleanupTooltips() {
    for (const tooltip of this.tooltips) {
      tooltip.remove();
    }
    this.tooltips = [];
  }
  async renderControls() {
    const controlsDiv = this.contentEl.createDiv({ cls: "timeline-controls" });
    const leftGroup = controlsDiv.createDiv({ cls: "timeline-controls-left" });
    const centerGroup = controlsDiv.createDiv({ cls: "timeline-controls-center" });
    const rightGroup = controlsDiv.createDiv({ cls: "timeline-controls-right" });
    this.renderModeSelector(rightGroup);
    this.renderMonthControls(rightGroup);
    this.renderCustomRangeControls(rightGroup);
    this.updateControlsVisibility();
    const prevButton = leftGroup.createEl("button", {
      text: "\u2190 Previous",
      cls: "mod-cta"
    });
    prevButton.addEventListener("click", async () => {
      await this.navigatePrevious();
    });
    const nextButton = leftGroup.createEl("button", {
      text: "Next \u2192",
      cls: "mod-cta"
    });
    nextButton.addEventListener("click", async () => {
      await this.navigateNext();
    });
    const todayButton = leftGroup.createEl("button", {
      text: "Today",
      cls: "mod-cta"
    });
    todayButton.addEventListener("click", async () => {
      await this.navigateToToday();
    });
    this.renderZoomControls(centerGroup);
  }
  renderModeSelector(container) {
    const modeContainer = container.createDiv({ cls: "timeline-mode-selector" });
    const modeSelect = modeContainer.createEl("select", { cls: "dropdown timeline-mode-select" });
    const monthOption = modeSelect.createEl("option", { value: "month", text: "Month View" });
    const customOption = modeSelect.createEl("option", { value: "custom", text: "Custom Range" });
    modeSelect.value = this.viewMode;
    modeSelect.addEventListener("change", async () => {
      this.viewMode = modeSelect.value;
      this.plugin.settings.viewMode = this.viewMode;
      await this.plugin.saveSettings();
      this.updateControlsVisibility();
      if (this.viewMode === "month") {
        const now = /* @__PURE__ */ new Date();
        this.startDate = new Date(now.getFullYear(), now.getMonth(), 1);
        this.endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
        if (this.monthSelectEl) {
          await this.updateMonthSelect(this.monthSelectEl);
        }
      }
      await this.renderTimeline();
    });
  }
  renderMonthControls(container) {
    const monthContainer = container.createDiv({ cls: "timeline-month-controls" });
    const monthSelect = monthContainer.createEl("select", { cls: "dropdown timeline-month-select" });
    this.monthSelectEl = monthSelect;
    this.populateMonthSelect(monthSelect);
    monthSelect.addEventListener("change", async () => {
      const [year, month] = monthSelect.value.split("-").map(Number);
      this.startDate = new Date(year, month, 1);
      this.endDate = new Date(year, month + 1, 0);
      this.zoomLevel = ZOOM_CONFIG.DEFAULT;
      await this.renderTimeline();
      this.updateZoomSlider();
    });
  }
  renderCustomRangeControls(container) {
    const customContainer = container.createDiv({ cls: "timeline-custom-range-controls" });
    this.customRangeContainerEl = customContainer;
    const quickRangeSelect = customContainer.createEl("select", { cls: "dropdown timeline-quick-range-select" });
    this.quickRangeSelectEl = quickRangeSelect;
    const presets = [
      { value: "last7days", label: "Last 7 Days" },
      { value: "last30days", label: "Last 30 Days" },
      { value: "thisweek", label: "This Week" },
      { value: "thismonth", label: "This Month" },
      { value: "last3months", label: "Last 3 Months" },
      { value: "custom", label: "Custom" }
    ];
    presets.forEach((preset) => {
      quickRangeSelect.createEl("option", { value: preset.value, text: preset.label });
    });
    quickRangeSelect.value = this.plugin.settings.lastQuickRangePreset;
    quickRangeSelect.addEventListener("change", async () => {
      const preset = quickRangeSelect.value;
      this.plugin.settings.lastQuickRangePreset = preset;
      await this.plugin.saveSettings();
      if (preset !== "custom") {
        this.applyQuickRangePreset(preset);
      }
    });
    const dateInputsContainer = customContainer.createDiv({ cls: "timeline-date-inputs" });
    const startLabel = dateInputsContainer.createSpan({ cls: "timeline-date-label", text: "From:" });
    const startDateInput = dateInputsContainer.createEl("input", {
      type: "date",
      cls: "timeline-date-input"
    });
    this.startDateInputEl = startDateInput;
    startDateInput.value = this.formatDateForInput(this.startDate);
    const endLabel = dateInputsContainer.createSpan({ cls: "timeline-date-label", text: "To:" });
    const endDateInput = dateInputsContainer.createEl("input", {
      type: "date",
      cls: "timeline-date-input"
    });
    this.endDateInputEl = endDateInput;
    endDateInput.value = this.formatDateForInput(this.endDate);
    startDateInput.addEventListener("change", async () => {
      await this.handleCustomDateChange();
    });
    endDateInput.addEventListener("change", async () => {
      await this.handleCustomDateChange();
    });
  }
  async handleCustomDateChange() {
    if (!this.startDateInputEl || !this.endDateInputEl) return;
    const startDateStr = this.startDateInputEl.value;
    const endDateStr = this.endDateInputEl.value;
    if (!startDateStr || !endDateStr) return;
    const newStartDate = new Date(startDateStr);
    const newEndDate = new Date(endDateStr);
    if (newEndDate < newStartDate) {
      alert("End date must be after or equal to start date");
      this.startDateInputEl.value = this.formatDateForInput(this.startDate);
      this.endDateInputEl.value = this.formatDateForInput(this.endDate);
      return;
    }
    const daysDiff = Math.ceil((newEndDate.getTime() - newStartDate.getTime()) / (1e3 * 60 * 60 * 24));
    if (daysDiff > 365) {
      alert("Date range cannot exceed 365 days");
      this.startDateInputEl.value = this.formatDateForInput(this.startDate);
      this.endDateInputEl.value = this.formatDateForInput(this.endDate);
      return;
    }
    this.startDate = newStartDate;
    this.endDate = newEndDate;
    this.plugin.settings.customStartDate = this.formatDateForStorage(this.startDate);
    this.plugin.settings.customEndDate = this.formatDateForStorage(this.endDate);
    await this.plugin.saveSettings();
    if (this.quickRangeSelectEl) {
      this.quickRangeSelectEl.value = "custom";
      this.plugin.settings.lastQuickRangePreset = "custom";
      await this.plugin.saveSettings();
    }
    this.zoomLevel = ZOOM_CONFIG.DEFAULT;
    await this.renderTimeline();
    this.updateZoomSlider();
  }
  applyQuickRangePreset(preset) {
    const now = /* @__PURE__ */ new Date();
    now.setHours(0, 0, 0, 0);
    switch (preset) {
      case "last7days":
        this.endDate = new Date(now);
        this.startDate = new Date(now);
        this.startDate.setDate(this.startDate.getDate() - 6);
        break;
      case "last30days":
        this.endDate = new Date(now);
        this.startDate = new Date(now);
        this.startDate.setDate(this.startDate.getDate() - 29);
        break;
      case "thisweek":
        const dayOfWeek = now.getDay();
        this.startDate = new Date(now);
        this.startDate.setDate(this.startDate.getDate() - dayOfWeek);
        this.endDate = new Date(this.startDate);
        this.endDate.setDate(this.endDate.getDate() + 6);
        break;
      case "thismonth":
        this.startDate = new Date(now.getFullYear(), now.getMonth(), 1);
        this.endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
        break;
      case "last3months":
        this.endDate = new Date(now);
        this.startDate = new Date(now);
        this.startDate.setMonth(this.startDate.getMonth() - 3);
        break;
    }
    if (this.startDateInputEl && this.endDateInputEl) {
      this.startDateInputEl.value = this.formatDateForInput(this.startDate);
      this.endDateInputEl.value = this.formatDateForInput(this.endDate);
    }
    this.plugin.settings.customStartDate = this.formatDateForStorage(this.startDate);
    this.plugin.settings.customEndDate = this.formatDateForStorage(this.endDate);
    this.plugin.saveSettings();
    this.zoomLevel = ZOOM_CONFIG.DEFAULT;
    this.renderTimeline();
    this.updateZoomSlider();
  }
  updateControlsVisibility() {
    if (this.monthSelectEl && this.monthSelectEl.parentElement) {
      if (this.viewMode === "month") {
        this.monthSelectEl.parentElement.style.display = "";
      } else {
        this.monthSelectEl.parentElement.style.display = "none";
      }
    }
    if (this.customRangeContainerEl) {
      if (this.viewMode === "custom") {
        this.customRangeContainerEl.style.display = "";
      } else {
        this.customRangeContainerEl.style.display = "none";
      }
    }
  }
  async navigatePrevious() {
    if (this.viewMode === "month") {
      this.startDate = new Date(
        this.startDate.getFullYear(),
        this.startDate.getMonth() - 1,
        1
      );
      this.endDate = new Date(
        this.endDate.getFullYear(),
        this.endDate.getMonth(),
        0
      );
      if (this.monthSelectEl) {
        await this.updateMonthSelect(this.monthSelectEl);
      }
    } else {
      const rangeDuration = this.getRangeDurationInDays();
      this.startDate.setDate(this.startDate.getDate() - rangeDuration);
      this.endDate.setDate(this.endDate.getDate() - rangeDuration);
      if (this.startDateInputEl && this.endDateInputEl) {
        this.startDateInputEl.value = this.formatDateForInput(this.startDate);
        this.endDateInputEl.value = this.formatDateForInput(this.endDate);
      }
      this.plugin.settings.customStartDate = this.formatDateForStorage(this.startDate);
      this.plugin.settings.customEndDate = this.formatDateForStorage(this.endDate);
      await this.plugin.saveSettings();
      if (this.quickRangeSelectEl) {
        this.quickRangeSelectEl.value = "custom";
      }
    }
    this.zoomLevel = ZOOM_CONFIG.DEFAULT;
    await this.renderTimeline();
    this.updateZoomSlider();
  }
  async navigateNext() {
    if (this.viewMode === "month") {
      this.startDate = new Date(
        this.startDate.getFullYear(),
        this.startDate.getMonth() + 1,
        1
      );
      this.endDate = new Date(
        this.endDate.getFullYear(),
        this.endDate.getMonth() + 2,
        0
      );
      if (this.monthSelectEl) {
        await this.updateMonthSelect(this.monthSelectEl);
      }
    } else {
      const rangeDuration = this.getRangeDurationInDays();
      this.startDate.setDate(this.startDate.getDate() + rangeDuration);
      this.endDate.setDate(this.endDate.getDate() + rangeDuration);
      if (this.startDateInputEl && this.endDateInputEl) {
        this.startDateInputEl.value = this.formatDateForInput(this.startDate);
        this.endDateInputEl.value = this.formatDateForInput(this.endDate);
      }
      this.plugin.settings.customStartDate = this.formatDateForStorage(this.startDate);
      this.plugin.settings.customEndDate = this.formatDateForStorage(this.endDate);
      await this.plugin.saveSettings();
      if (this.quickRangeSelectEl) {
        this.quickRangeSelectEl.value = "custom";
      }
    }
    this.zoomLevel = ZOOM_CONFIG.DEFAULT;
    await this.renderTimeline();
    this.updateZoomSlider();
  }
  async navigateToToday() {
    this.viewMode = "month";
    this.plugin.settings.viewMode = "month";
    await this.plugin.saveSettings();
    const now = /* @__PURE__ */ new Date();
    this.startDate = new Date(now.getFullYear(), now.getMonth(), 1);
    this.endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
    this.updateControlsVisibility();
    if (this.monthSelectEl) {
      await this.updateMonthSelect(this.monthSelectEl);
    }
    const modeSelect = this.contentEl.querySelector(".timeline-mode-select");
    if (modeSelect) {
      modeSelect.value = "month";
    }
    this.zoomLevel = ZOOM_CONFIG.DEFAULT;
    await this.renderTimeline();
    this.updateZoomSlider();
  }
  renderZoomControls(container) {
    const zoomContainer = container.createDiv({ cls: "timeline-zoom-controls" });
    const zoomOutButton = zoomContainer.createEl("button", {
      cls: "timeline-zoom-button",
      attr: { "aria-label": "Zoom out" }
    });
    zoomOutButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.35-4.35"></path><line x1="8" y1="11" x2="14" y2="11"></line></svg>';
    zoomOutButton.addEventListener("click", () => {
      const newZoom = Math.max(ZOOM_CONFIG.MIN, this.zoomLevel - ZOOM_CONFIG.STEP);
      this.applyZoom(newZoom);
    });
    const sliderContainer = zoomContainer.createDiv({ cls: "timeline-zoom-slider-container" });
    const zoomSlider = sliderContainer.createEl("input", {
      type: "range",
      cls: "timeline-zoom-slider"
    });
    zoomSlider.min = String(ZOOM_CONFIG.MIN * 100);
    zoomSlider.max = String(ZOOM_CONFIG.MAX * 100);
    zoomSlider.value = String(this.zoomLevel * 100);
    zoomSlider.step = String(ZOOM_CONFIG.STEP * 100);
    const zoomLabel = sliderContainer.createDiv({ cls: "timeline-zoom-label" });
    zoomLabel.setText(`${Math.round(this.zoomLevel * 100)}%`);
    const zoomInButton = zoomContainer.createEl("button", {
      cls: "timeline-zoom-button",
      attr: { "aria-label": "Zoom in" }
    });
    zoomInButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.35-4.35"></path><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>';
    zoomInButton.addEventListener("click", () => {
      const newZoom = Math.min(ZOOM_CONFIG.MAX, this.zoomLevel + ZOOM_CONFIG.STEP);
      this.applyZoom(newZoom);
    });
    zoomSlider.addEventListener("input", () => {
      const newZoomLevel = parseFloat(zoomSlider.value) / 100;
      zoomLabel.setText(`${Math.round(newZoomLevel * 100)}%`);
    });
    zoomSlider.addEventListener("change", () => {
      const newZoomLevel = parseFloat(zoomSlider.value) / 100;
      this.applyZoom(newZoomLevel);
    });
    this.zoomSlider = zoomSlider;
    this.zoomLabel = zoomLabel;
  }
  updateZoomSlider() {
    if (this.zoomSlider) {
      this.zoomSlider.value = String(this.zoomLevel * 100);
    }
    if (this.zoomLabel) {
      this.zoomLabel.setText(`${Math.round(this.zoomLevel * 100)}%`);
    }
  }
  applyZoom(newZoomLevel, anchorX) {
    if (!this.timelineContainerEl) return;
    const scrollContainer = this.timelineContainerEl;
    const scrollLeft = scrollContainer.scrollLeft;
    const containerWidth = scrollContainer.clientWidth;
    const scrollWidth = scrollContainer.scrollWidth;
    let contentAnchorX;
    if (anchorX !== void 0) {
      contentAnchorX = scrollLeft + anchorX;
    } else {
      contentAnchorX = scrollLeft + containerWidth / 2;
    }
    const anchorRatio = contentAnchorX / scrollWidth;
    this.zoomLevel = newZoomLevel;
    this.updateZoomSlider();
    this.renderTimeline().then(() => {
      if (!this.timelineContainerEl) return;
      const newScrollWidth = this.timelineContainerEl.scrollWidth;
      const newContentAnchorX = anchorRatio * newScrollWidth;
      const newScrollLeft = anchorX !== void 0 ? newContentAnchorX - anchorX : newContentAnchorX - containerWidth / 2;
      this.timelineContainerEl.scrollLeft = Math.max(0, newScrollLeft);
    });
  }
  setupTimelineInteractions(timelineContainer) {
    timelineContainer.addEventListener("wheel", (e) => {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        const rect = timelineContainer.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const delta = -e.deltaY;
        const zoomFactor = delta > 0 ? ZOOM_CONFIG.STEP : -ZOOM_CONFIG.STEP;
        const newZoom = Math.max(
          ZOOM_CONFIG.MIN,
          Math.min(ZOOM_CONFIG.MAX, this.zoomLevel + zoomFactor)
        );
        this.applyZoom(newZoom, mouseX);
      } else {
        e.preventDefault();
        timelineContainer.scrollLeft += e.deltaY;
      }
    });
    timelineContainer.addEventListener("mousedown", (e) => {
      if (e.button !== 0) return;
      const target = e.target;
      if (target.closest(".timeline-task") || target.closest("a")) {
        return;
      }
      e.preventDefault();
      this.isDragging = true;
      this.dragStartX = e.clientX;
      this.dragStartScrollLeft = timelineContainer.scrollLeft;
      timelineContainer.style.cursor = "grabbing";
      timelineContainer.style.userSelect = "none";
    });
    const handleMouseMove = (e) => {
      if (!this.isDragging || !this.timelineContainerEl) return;
      e.preventDefault();
      const deltaX = e.clientX - this.dragStartX;
      this.timelineContainerEl.scrollLeft = this.dragStartScrollLeft - deltaX;
    };
    const handleMouseUp = () => {
      if (this.isDragging && this.timelineContainerEl) {
        this.isDragging = false;
        this.timelineContainerEl.style.cursor = "grab";
        this.timelineContainerEl.style.userSelect = "";
      }
    };
    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    timelineContainer.addEventListener("mouseleave", () => {
      if (this.isDragging && this.timelineContainerEl) {
        this.isDragging = false;
        this.timelineContainerEl.style.cursor = "grab";
        this.timelineContainerEl.style.userSelect = "";
      }
    });
  }
  async populateMonthSelect(select) {
    const availableMonths = await this.plugin.parser.getAvailableMonths(
      this.plugin.settings.dailyNotesFolder,
      this.plugin.settings.dateFormat
    );
    select.empty();
    for (const monthKey of availableMonths) {
      const [year, month] = monthKey.split("-").map(Number);
      const date = new Date(year, month, 1);
      const option = select.createEl("option");
      option.value = monthKey;
      option.text = date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long"
      });
      if (year === this.startDate.getFullYear() && month === this.startDate.getMonth()) {
        option.selected = true;
      }
    }
  }
  async updateMonthSelect(select) {
    select.value = `${this.startDate.getFullYear()}-${this.startDate.getMonth()}`;
  }
  async renderTimeline() {
    this.cleanupTooltips();
    const existingTimeline = this.contentEl.querySelector(".timeline-scroll");
    if (existingTimeline) {
      existingTimeline.remove();
    }
    const timelineScroll = this.contentEl.createDiv({
      cls: "timeline-scroll"
    });
    this.timelineScrollEl = timelineScroll;
    const dailyNotes = await this.plugin.parser.parseDailyNotes(
      this.plugin.settings.dailyNotesFolder,
      this.plugin.settings.dateFormat,
      this.startDate,
      this.endDate
    );
    if (dailyNotes.length === 0) {
      timelineScroll.createDiv({
        cls: "timeline-empty",
        text: "No date range selected"
      });
      return;
    }
    await this.renderContinuousTimeline(timelineScroll, dailyNotes);
  }
  async renderContinuousTimeline(container, dailyNotes) {
    const timelineContainer = container.createDiv({ cls: "timeline-continuous" });
    this.timelineContainerEl = timelineContainer;
    this.setupTimelineInteractions(timelineContainer);
    const timelineTrack = timelineContainer.createDiv({ cls: "timeline-track-continuous" });
    const segmentWidth = ZOOM_CONFIG.BASE_SEGMENT_WIDTH * this.zoomLevel;
    const totalWidth = segmentWidth * dailyNotes.length;
    timelineTrack.style.width = `${totalWidth}px`;
    for (let i = 0; i < dailyNotes.length; i++) {
      const note = dailyNotes[i];
      await this.renderDaySegment(timelineTrack, note, i, dailyNotes.length, segmentWidth);
    }
  }
  groupOverlappingTasks(tasks, segmentWidth) {
    if (tasks.length === 0) return [];
    if (!this.plugin.settings.enableGrouping) {
      return tasks;
    }
    const sortedTasks = [...tasks].sort((a, b) => {
      const aMinutes = a.hour * 60 + a.minute;
      const bMinutes = b.hour * 60 + b.minute;
      return aMinutes - bMinutes;
    });
    const MIN_SPACING_PIXELS = this.plugin.settings.minSpacingPixels;
    const MAX_GROUP_SPAN_PIXELS = this.plugin.settings.maxGroupSpanPixels;
    const groups = [];
    let currentGroup = [sortedTasks[0]];
    for (let i = 1; i < sortedTasks.length; i++) {
      const prevTask = sortedTasks[i - 1];
      const currTask = sortedTasks[i];
      const prevPercentage = (prevTask.hour * 60 + prevTask.minute) / (24 * 60) * 100;
      const currPercentage = (currTask.hour * 60 + currTask.minute) / (24 * 60) * 100;
      const pixelDiff = Math.abs(currPercentage - prevPercentage) * (segmentWidth / 100);
      const firstTaskPercentage = (currentGroup[0].hour * 60 + currentGroup[0].minute) / (24 * 60) * 100;
      const groupSpan = Math.abs(currPercentage - firstTaskPercentage) * (segmentWidth / 100);
      if (pixelDiff < MIN_SPACING_PIXELS && groupSpan < MAX_GROUP_SPAN_PIXELS) {
        currentGroup.push(currTask);
      } else {
        if (currentGroup.length > 1) {
          const avgMinutes = currentGroup.reduce((sum, t) => sum + (t.hour * 60 + t.minute), 0) / currentGroup.length;
          const avgPercentage = avgMinutes / (24 * 60) * 100;
          const avgHour = Math.floor(avgMinutes / 60);
          const avgMinute = Math.floor(avgMinutes % 60);
          groups.push({
            tasks: currentGroup,
            position: avgPercentage,
            averageTime: `${String(avgHour).padStart(2, "0")}:${String(avgMinute).padStart(2, "0")}`
          });
        } else {
          groups.push(currentGroup[0]);
        }
        currentGroup = [currTask];
      }
    }
    if (currentGroup.length > 1) {
      const avgMinutes = currentGroup.reduce((sum, t) => sum + (t.hour * 60 + t.minute), 0) / currentGroup.length;
      const avgPercentage = avgMinutes / (24 * 60) * 100;
      const avgHour = Math.floor(avgMinutes / 60);
      const avgMinute = Math.floor(avgMinutes % 60);
      groups.push({
        tasks: currentGroup,
        position: avgPercentage,
        averageTime: `${String(avgHour).padStart(2, "0")}:${String(avgMinute).padStart(2, "0")}`
      });
    } else {
      groups.push(currentGroup[0]);
    }
    return groups;
  }
  async renderDaySegment(track, note, index, total, segmentWidth) {
    const segment = track.createDiv({ cls: "timeline-segment" });
    segment.style.width = `${segmentWidth}px`;
    segment.style.left = `${segmentWidth * index}px`;
    if (note.tasks.length === 0) {
      segment.addClass("timeline-segment-empty");
    }
    const dateObj = new Date(note.date);
    const dateLabel = segment.createDiv({ cls: "timeline-segment-date" });
    dateLabel.setText(
      dateObj.toLocaleDateString("en-US", {
        month: "short",
        day: "numeric"
      })
    );
    if (note.path) {
      dateLabel.addClass("timeline-segment-date-clickable");
      dateLabel.addEventListener("click", async (e) => {
        e.preventDefault();
        const file = this.app.vault.getAbstractFileByPath(note.path);
        if (file) {
          await this.app.workspace.getLeaf(false).openFile(file);
        }
      });
    }
    const weekdayLabel = segment.createDiv({ cls: "timeline-segment-weekday" });
    weekdayLabel.setText(
      dateObj.toLocaleDateString("en-US", {
        weekday: "short"
      })
    );
    const startLabel = segment.createDiv({ cls: "timeline-segment-time timeline-segment-time-start" });
    startLabel.setText("00:00");
    const endLabel = segment.createDiv({ cls: "timeline-segment-time timeline-segment-time-end" });
    endLabel.setText("23:59");
    const groupedItems = this.groupOverlappingTasks(note.tasks, segmentWidth);
    for (const item of groupedItems) {
      if ("tasks" in item) {
        await this.renderGroupedTaskInSegment(segment, item);
      } else {
        await this.renderTaskInSegment(segment, item);
      }
    }
  }
  getTagStyle(tag) {
    if (!tag) return null;
    return this.plugin.settings.tagStyles.find((style) => style.tag === tag);
  }
  async renderGroupedTaskInSegment(segment, groupedTask) {
    const taskDotContainer = segment.createDiv({ cls: "timeline-task-dot-container timeline-task-grouped" });
    const clampedPosition = Math.min(groupedTask.position, 96);
    taskDotContainer.style.left = `${clampedPosition}%`;
    const taskDot = taskDotContainer.createDiv({ cls: "timeline-task-dot" });
    taskDot.setAttribute("data-status", "grouped");
    const countBadge = taskDot.createDiv({ cls: "timeline-task-count-badge" });
    countBadge.setText(String(groupedTask.tasks.length));
    const emojiContainer = taskDotContainer.createDiv({ cls: "timeline-emoji-stack" });
    const emojiSet = /* @__PURE__ */ new Set();
    for (const task of groupedTask.tasks) {
      const tagStyle = this.getTagStyle(task.firstTag);
      if (tagStyle && tagStyle.emoji) {
        emojiSet.add(tagStyle.emoji);
      } else if (task.hasAttachment && !emojiSet.has("\u{1F4F8}")) {
        emojiSet.add("\u{1F4F8}");
      }
    }
    emojiSet.forEach((emoji) => {
      const emojiEl = emojiContainer.createDiv({ cls: "timeline-task-emoji" });
      emojiEl.setText(emoji);
    });
    const tooltip = document.body.createDiv({ cls: "timeline-tooltip" });
    this.tooltips.push(tooltip);
    const tooltipWrapper = tooltip.createDiv({ cls: "timeline-tooltip-wrapper" });
    for (let i = 0; i < groupedTask.tasks.length; i++) {
      const task = groupedTask.tasks[i];
      const tooltipContent = tooltipWrapper.createDiv({ cls: "timeline-tooltip-content" });
      if (i > 0) {
        tooltipContent.addClass("timeline-tooltip-stacked");
      }
      const timeHeader = tooltipContent.createDiv({ cls: "timeline-tooltip-time" });
      const taskTagStyle = this.getTagStyle(task.firstTag);
      if (taskTagStyle && taskTagStyle.emoji) {
        const emojiSpan = timeHeader.createSpan({ cls: "timeline-tooltip-time-emoji" });
        emojiSpan.setText(taskTagStyle.emoji);
      }
      const timeText = timeHeader.createSpan();
      timeText.setText(task.time);
      const taskText = tooltipContent.createDiv({ cls: "timeline-tooltip-task" });
      taskText.textContent = `[${task.status}] `;
      await this.renderTaskContent(taskText, task.content);
      if (task.subItems.length > 0) {
        const subList = tooltipContent.createEl("ul", { cls: "timeline-tooltip-subitems" });
        for (const subItem of task.subItems) {
          const listItem = subList.createEl("li");
          await this.renderTaskContent(listItem, subItem);
        }
      }
    }
    taskDotContainer.addEventListener("mouseenter", () => {
      const rect = taskDotContainer.getBoundingClientRect();
      const viewportHeight = window.innerHeight;
      const tooltipEstimatedHeight = groupedTask.tasks.length * 120;
      let tooltipTop = rect.bottom + 12;
      let tooltipLeft = rect.left + rect.width / 2;
      let transform = "translateX(-50%)";
      let isAbove = false;
      if (tooltipTop + tooltipEstimatedHeight > viewportHeight - 20) {
        const availableHeight = viewportHeight - tooltipTop - 20;
        if (availableHeight < 200) {
          tooltipTop = rect.top - Math.min(tooltipEstimatedHeight, viewportHeight * 0.6) - 12;
          isAbove = true;
          if (tooltipTop < 20) {
            tooltipTop = 20;
          }
        }
      }
      const maxHeight = Math.min(viewportHeight * 0.7, tooltipEstimatedHeight);
      tooltipWrapper.style.maxHeight = `${maxHeight}px`;
      if (isAbove) {
        tooltip.addClass("tooltip-above");
      } else {
        tooltip.removeClass("tooltip-above");
      }
      tooltip.style.top = `${tooltipTop}px`;
      tooltip.style.left = `${tooltipLeft}px`;
      tooltip.style.transform = transform;
      tooltip.addClass("is-visible");
      taskDotContainer.addClass("is-hovered");
    });
    taskDotContainer.addEventListener("mouseleave", () => {
      tooltip.removeClass("is-visible");
      tooltip.removeClass("tooltip-above");
      taskDotContainer.removeClass("is-hovered");
    });
    tooltip.addEventListener("mouseenter", () => {
      tooltip.addClass("is-visible");
      taskDotContainer.addClass("is-hovered");
    });
    tooltip.addEventListener("mouseleave", () => {
      tooltip.removeClass("is-visible");
      tooltip.removeClass("tooltip-above");
      taskDotContainer.removeClass("is-hovered");
    });
  }
  async renderTaskInSegment(segment, task) {
    const totalMinutes = task.hour * 60 + task.minute;
    let percentage = totalMinutes / (24 * 60) * 100;
    percentage = Math.min(percentage, 96);
    const taskDotContainer = segment.createDiv({ cls: "timeline-task-dot-container" });
    taskDotContainer.style.left = `${percentage}%`;
    const taskDot = taskDotContainer.createDiv({ cls: "timeline-task-dot" });
    taskDot.setAttribute("data-status", task.status);
    const tagStyle = this.getTagStyle(task.firstTag);
    if (tagStyle && tagStyle.color) {
      taskDot.addClass("timeline-task-dot-custom");
      taskDot.style.setProperty("background-color", tagStyle.color, "important");
    }
    const taskLabel = taskDot.createDiv({ cls: "timeline-task-label" });
    taskLabel.setText(task.time);
    const emojiContainer = taskDotContainer.createDiv({ cls: "timeline-emoji-stack" });
    if (tagStyle && tagStyle.emoji) {
      const emojiEl = emojiContainer.createDiv({ cls: "timeline-task-emoji" });
      emojiEl.setText(tagStyle.emoji);
    } else if (task.hasAttachment) {
      const emojiEl = emojiContainer.createDiv({ cls: "timeline-task-emoji" });
      emojiEl.setText("\u{1F4F8}");
    }
    const tooltip = document.body.createDiv({ cls: "timeline-tooltip" });
    this.tooltips.push(tooltip);
    const tooltipContent = tooltip.createDiv({ cls: "timeline-tooltip-content" });
    const timeHeader = tooltipContent.createDiv({ cls: "timeline-tooltip-time" });
    if (tagStyle && tagStyle.emoji) {
      const emojiSpan = timeHeader.createSpan({ cls: "timeline-tooltip-time-emoji" });
      emojiSpan.setText(tagStyle.emoji);
    }
    const timeText = timeHeader.createSpan();
    timeText.setText(task.time);
    const taskText = tooltipContent.createDiv({ cls: "timeline-tooltip-task" });
    taskText.textContent = `[${task.status}] `;
    await this.renderTaskContent(taskText, task.content);
    if (task.subItems.length > 0) {
      const subList = tooltipContent.createEl("ul", { cls: "timeline-tooltip-subitems" });
      for (const subItem of task.subItems) {
        const listItem = subList.createEl("li");
        await this.renderTaskContent(listItem, subItem);
      }
    }
    taskDotContainer.addEventListener("mouseenter", () => {
      const rect = taskDotContainer.getBoundingClientRect();
      const viewportHeight = window.innerHeight;
      let tooltipTop = rect.bottom + 12;
      setTimeout(() => {
        const tooltipHeight = tooltip.offsetHeight;
        if (tooltipTop + tooltipHeight > viewportHeight - 20) {
          tooltipTop = rect.top - tooltipHeight - 12;
          tooltip.addClass("tooltip-above");
          if (tooltipTop < 20) {
            tooltipTop = 20;
          }
        } else {
          tooltip.removeClass("tooltip-above");
        }
        tooltip.style.top = `${tooltipTop}px`;
      }, 0);
      tooltip.style.top = `${tooltipTop}px`;
      tooltip.style.left = `${rect.left + rect.width / 2}px`;
      tooltip.style.transform = "translateX(-50%)";
      tooltip.addClass("is-visible");
      taskDotContainer.addClass("is-hovered");
    });
    taskDotContainer.addEventListener("mouseleave", () => {
      tooltip.removeClass("is-visible");
      tooltip.removeClass("tooltip-above");
      taskDotContainer.removeClass("is-hovered");
    });
    tooltip.addEventListener("mouseenter", () => {
      tooltip.addClass("is-visible");
      taskDotContainer.addClass("is-hovered");
    });
    tooltip.addEventListener("mouseleave", () => {
      tooltip.removeClass("is-visible");
      tooltip.removeClass("tooltip-above");
      taskDotContainer.removeClass("is-hovered");
    });
  }
  async renderTaskContent(container, content) {
    const combinedRegex = /(!\[\[([^\]]+)\]\])|(\[\[([^\]]+)\]\])/g;
    let lastIndex = 0;
    let match;
    while ((match = combinedRegex.exec(content)) !== null) {
      if (match.index > lastIndex) {
        await this.renderTextWithLinks(container, content.substring(lastIndex, match.index));
      }
      if (match[1]) {
        const imageName = match[2];
        await this.renderImage(container, imageName);
      } else if (match[3]) {
        const linkText = match[4];
        this.renderLink(container, linkText);
      }
      lastIndex = match.index + match[0].length;
    }
    if (lastIndex < content.length) {
      await this.renderTextWithLinks(container, content.substring(lastIndex));
    }
  }
  async renderTextWithLinks(container, text) {
    const tagRegex = /#([\p{L}\p{N}_\/-]+)/gu;
    let lastIndex = 0;
    let match;
    while ((match = tagRegex.exec(text)) !== null) {
      if (match.index > lastIndex) {
        const textSpan = container.createSpan();
        textSpan.textContent = text.substring(lastIndex, match.index);
      }
      const tagText = match[1];
      const tagLink = container.createEl("a", {
        cls: "tag timeline-tooltip-tag",
        href: "#"
      });
      tagLink.textContent = `#${tagText}`;
      tagLink.addEventListener("click", async (e) => {
        var _a;
        e.preventDefault();
        (_a = this.app.internalPlugins.getPluginById("global-search")) == null ? void 0 : _a.instance.openGlobalSearch(`tag:#${tagText}`);
      });
      lastIndex = match.index + match[0].length;
    }
    if (lastIndex < text.length) {
      const textSpan = container.createSpan();
      textSpan.textContent = text.substring(lastIndex);
    }
  }
  renderLink(container, linkText) {
    const pipeSplit = linkText.split("|");
    const actualLink = pipeSplit[0].trim();
    const displayText = pipeSplit.length > 1 ? pipeSplit[1].trim() : actualLink;
    const link = container.createEl("a", {
      cls: "internal-link timeline-tooltip-link",
      href: "#"
    });
    link.textContent = displayText;
    link.addEventListener("click", async (e) => {
      e.preventDefault();
      const file = this.plugin.app.metadataCache.getFirstLinkpathDest(actualLink, "");
      if (file) {
        await this.plugin.app.workspace.getLeaf(false).openFile(file);
      }
    });
  }
  async renderImage(container, imageName) {
    const imageFile = this.plugin.app.vault.getAbstractFileByPath(imageName);
    if (imageFile && imageFile instanceof this.plugin.app.vault.adapter.constructor) {
      const imageContainer = container.createDiv({ cls: "timeline-tooltip-image" });
      const img = imageContainer.createEl("img");
      const resourcePath = this.plugin.app.vault.getResourcePath(imageFile);
      img.src = resourcePath;
      img.alt = imageName;
    } else {
      const files = this.plugin.app.vault.getFiles();
      const matchedFile = files.find((f) => f.name === imageName || f.path.endsWith(imageName));
      if (matchedFile) {
        const imageContainer = container.createDiv({ cls: "timeline-tooltip-image" });
        const img = imageContainer.createEl("img");
        const resourcePath = this.plugin.app.vault.getResourcePath(matchedFile);
        img.src = resourcePath;
        img.alt = imageName;
      }
    }
  }
};

// settings.ts
var import_obsidian2 = require("obsidian");
var TimelineSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Daily Notes Timeline Settings" });
    new import_obsidian2.Setting(containerEl).setName("Daily Notes Folder").setDesc(
      "Path to your daily notes folder (leave empty for vault root or default daily notes location)"
    ).addText(
      (text) => text.setPlaceholder("Daily Notes").setValue(this.plugin.settings.dailyNotesFolder).onChange(async (value) => {
        this.plugin.settings.dailyNotesFolder = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Date Format").setDesc("Format used in daily note filenames (e.g., YYYY-MM-DD)").addText(
      (text) => text.setPlaceholder("YYYY-MM-DD").setValue(this.plugin.settings.dateFormat).onChange(async (value) => {
        this.plugin.settings.dateFormat = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Default Timeline Range").setDesc("Number of months to display by default").addSlider(
      (slider) => slider.setLimits(1, 12, 1).setValue(this.plugin.settings.defaultRangeMonths).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.defaultRangeMonths = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h2", { text: "Tag Styles" });
    containerEl.createEl("p", {
      text: "Customize the appearance of timeline points based on the first hashtag in each task.",
      cls: "setting-item-description"
    });
    this.displayTagStylesList(containerEl);
    this.displayAddTagStyleForm(containerEl);
    this.displayGroupingSettings(containerEl);
  }
  displayGroupingSettings(containerEl) {
    containerEl.createEl("h2", { text: "Points Grouping" });
    containerEl.createEl("p", {
      text: "Configure how timeline points are grouped when they appear close together. Grouping helps reduce visual clutter by combining nearby tasks into a single point with a count badge.",
      cls: "setting-item-description"
    });
    new import_obsidian2.Setting(containerEl).setName("Enable Grouping").setDesc("When enabled, tasks that appear close together on the timeline will be automatically grouped").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.enableGrouping).onChange(async (value) => {
        this.plugin.settings.enableGrouping = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Minimum Spacing").setDesc("Minimum distance (in pixels) between tasks before they are grouped together. Lower values create more groups.").addSlider(
      (slider) => slider.setLimits(10, 100, 5).setValue(this.plugin.settings.minSpacingPixels).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.minSpacingPixels = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).setName("Maximum Group Span").setDesc("Maximum distance (in pixels) between the first and last task in a group. Prevents overly large groups.").addSlider(
      (slider) => slider.setLimits(30, 150, 10).setValue(this.plugin.settings.maxGroupSpanPixels).setDynamicTooltip().onChange(async (value) => {
        this.plugin.settings.maxGroupSpanPixels = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian2.Setting(containerEl).addButton(
      (button) => button.setButtonText("Reset to Defaults").setTooltip("Restore default grouping settings").onClick(async () => {
        this.plugin.settings.enableGrouping = true;
        this.plugin.settings.minSpacingPixels = 25;
        this.plugin.settings.maxGroupSpanPixels = 60;
        await this.plugin.saveSettings();
        this.display();
      })
    );
  }
  displayTagStylesList(containerEl) {
    const listContainer = containerEl.createDiv({ cls: "tag-styles-list" });
    if (this.plugin.settings.tagStyles.length === 0) {
      listContainer.createEl("p", {
        text: "No tag styles configured yet. Add one below.",
        cls: "setting-item-description"
      });
      return;
    }
    this.plugin.settings.tagStyles.forEach((preset, index) => {
      const presetContainer = listContainer.createDiv({ cls: "tag-style-preset" });
      const infoDiv = presetContainer.createDiv({ cls: "tag-style-info" });
      const colorSwatch = infoDiv.createDiv({ cls: "tag-style-color-swatch" });
      colorSwatch.style.backgroundColor = preset.color;
      const tagName = infoDiv.createSpan({ cls: "tag-style-tag-name" });
      tagName.setText(`#${preset.tag}`);
      if (preset.emoji) {
        const emojiPreview = infoDiv.createSpan({ cls: "tag-style-emoji-preview" });
        emojiPreview.setText(preset.emoji);
      }
      const actionsDiv = presetContainer.createDiv({ cls: "tag-style-actions" });
      const editButton = actionsDiv.createEl("button", { text: "Edit", cls: "mod-cta" });
      editButton.addEventListener("click", () => {
        this.editTagStyle(index, preset);
      });
      const deleteButton = actionsDiv.createEl("button", { text: "Delete", cls: "mod-warning" });
      deleteButton.addEventListener("click", async () => {
        this.plugin.settings.tagStyles.splice(index, 1);
        await this.plugin.saveSettings();
        this.display();
      });
    });
  }
  displayAddTagStyleForm(containerEl) {
    containerEl.createEl("h3", { text: "Add New Tag Style" });
    const formContainer = containerEl.createDiv({ cls: "tag-style-form" });
    let tagInput;
    let colorInput;
    let emojiInput;
    new import_obsidian2.Setting(formContainer).setName("Tag Name").setDesc("Enter tag name without the # symbol (e.g., 'log' for #log, or 'log/work' for #log/work)").addText((text) => {
      tagInput = text.inputEl;
      text.setPlaceholder("log/work");
    });
    new import_obsidian2.Setting(formContainer).setName("Color").setDesc("Choose a color for the timeline point").addColorPicker((color) => {
      colorInput = color.colorPickerEl;
      color.setValue("#3b82f6");
    });
    new import_obsidian2.Setting(formContainer).setName("Emoji (Optional)").setDesc("Enter an emoji to display below the timeline point").addText((text) => {
      emojiInput = text.inputEl;
      text.setPlaceholder("\u{1F4DD}");
    });
    new import_obsidian2.Setting(formContainer).addButton(
      (button) => button.setButtonText("Add Style").setCta().onClick(async () => {
        const tag = tagInput.value.trim().toLowerCase();
        const color = colorInput.value;
        const emoji = emojiInput.value.trim();
        if (!tag) {
          alert("Please enter a tag name");
          return;
        }
        if (this.plugin.settings.tagStyles.some((s) => s.tag === tag)) {
          alert(`A style for tag "${tag}" already exists`);
          return;
        }
        this.plugin.settings.tagStyles.push({ tag, color, emoji });
        await this.plugin.saveSettings();
        this.display();
      })
    );
  }
  editTagStyle(index, preset) {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Edit Tag Style" });
    const formContainer = containerEl.createDiv({ cls: "tag-style-form" });
    let tagInput;
    let colorInput;
    let emojiInput;
    new import_obsidian2.Setting(formContainer).setName("Tag Name").setDesc("Tag name without the # symbol").addText((text) => {
      tagInput = text.inputEl;
      text.setValue(preset.tag);
    });
    new import_obsidian2.Setting(formContainer).setName("Color").setDesc("Choose a color for the timeline point").addColorPicker((color) => {
      colorInput = color.colorPickerEl;
      color.setValue(preset.color);
    });
    new import_obsidian2.Setting(formContainer).setName("Emoji (Optional)").setDesc("Enter an emoji to display below the timeline point").addText((text) => {
      emojiInput = text.inputEl;
      text.setValue(preset.emoji || "");
    });
    new import_obsidian2.Setting(formContainer).addButton(
      (button) => button.setButtonText("Save").setCta().onClick(async () => {
        const tag = tagInput.value.trim().toLowerCase();
        const color = colorInput.value;
        const emoji = emojiInput.value.trim();
        if (!tag) {
          alert("Please enter a tag name");
          return;
        }
        const existingIndex = this.plugin.settings.tagStyles.findIndex((s) => s.tag === tag);
        if (existingIndex !== -1 && existingIndex !== index) {
          alert(`A style for tag "${tag}" already exists`);
          return;
        }
        this.plugin.settings.tagStyles[index] = { tag, color, emoji };
        await this.plugin.saveSettings();
        this.display();
      })
    ).addButton(
      (button) => button.setButtonText("Cancel").onClick(() => {
        this.display();
      })
    );
  }
};

// parser.ts
var DailyNotesParser = class {
  constructor(vault) {
    __publicField(this, "vault");
    this.vault = vault;
  }
  async getAvailableMonths(folderPath, dateFormat) {
    const monthsSet = /* @__PURE__ */ new Set();
    const files = this.vault.getMarkdownFiles();
    for (const file of files) {
      if (this.isInDailyNotesFolder(file.path, folderPath)) {
        const dateStr = this.extractDateFromFilename(file.name, dateFormat);
        if (dateStr) {
          const noteDate = this.parseDate(dateStr);
          if (noteDate) {
            const monthKey = `${noteDate.getFullYear()}-${noteDate.getMonth()}`;
            monthsSet.add(monthKey);
          }
        }
      }
    }
    return Array.from(monthsSet).sort();
  }
  async parseDailyNotes(folderPath, dateFormat, startDate, endDate) {
    const dailyNotesMap = /* @__PURE__ */ new Map();
    const files = this.vault.getMarkdownFiles();
    for (const file of files) {
      if (this.isInDailyNotesFolder(file.path, folderPath)) {
        const dateStr = this.extractDateFromFilename(file.name, dateFormat);
        if (dateStr) {
          const noteDate = this.parseDate(dateStr);
          if (noteDate && noteDate >= startDate && noteDate <= endDate) {
            const tasks = await this.extractTasks(file);
            dailyNotesMap.set(dateStr, {
              date: dateStr,
              path: file.path,
              tasks
            });
          }
        }
      }
    }
    const allDates = this.getAllDatesInRange(startDate, endDate);
    const dailyNotes = [];
    for (const dateStr of allDates) {
      if (dailyNotesMap.has(dateStr)) {
        dailyNotes.push(dailyNotesMap.get(dateStr));
      } else {
        dailyNotes.push({
          date: dateStr,
          path: "",
          tasks: []
        });
      }
    }
    return dailyNotes;
  }
  getAllDatesInRange(startDate, endDate) {
    const dates = [];
    const current = new Date(startDate);
    while (current <= endDate) {
      const year = current.getFullYear();
      const month = String(current.getMonth() + 1).padStart(2, "0");
      const day = String(current.getDate()).padStart(2, "0");
      dates.push(`${year}-${month}-${day}`);
      current.setDate(current.getDate() + 1);
    }
    return dates;
  }
  isInDailyNotesFolder(filePath, folderPath) {
    if (!folderPath) return true;
    return filePath.startsWith(folderPath);
  }
  extractDateFromFilename(filename, dateFormat) {
    const nameWithoutExt = filename.replace(/\.md$/, "");
    if (dateFormat === "YYYY-MM-DD") {
      const match = nameWithoutExt.match(/(\d{4}-\d{2}-\d{2})/);
      return match ? match[1] : null;
    }
    return nameWithoutExt;
  }
  parseDate(dateStr) {
    try {
      const [year, month, day] = dateStr.split("-").map(Number);
      return new Date(year, month - 1, day);
    } catch (e) {
      return null;
    }
  }
  extractFirstTag(content) {
    const tagRegex = /#([\p{L}\p{N}_/-]+)/u;
    const match = content.match(tagRegex);
    return match ? match[1].toLowerCase() : void 0;
  }
  hasImageAttachment(content) {
    const imageRegex = /!\[\[.*?\.(png|jpg|jpeg|gif|webp|bmp|svg)\]\]|!\[.*?\]\(.*?\.(png|jpg|jpeg|gif|webp|bmp|svg)\)/i;
    return imageRegex.test(content);
  }
  async extractTasks(file) {
    const content = await this.vault.cachedRead(file);
    const lines = content.split("\n");
    const tasks = [];
    let currentTask = null;
    const taskRegex = /^- \[([^\]]+)\]\s+\*(\d{2}:\d{2})\*\s+(.+)$/;
    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const match = line.match(taskRegex);
      if (match) {
        if (currentTask) {
          this.finalizeTask(currentTask);
          tasks.push(currentTask);
        }
        const [, status, time, content2] = match;
        const [hour, minute] = time.split(":").map(Number);
        const firstTag = this.extractFirstTag(content2);
        currentTask = {
          status,
          time,
          content: content2.trim(),
          subItems: [],
          date: this.extractDateFromFilename(file.name, "YYYY-MM-DD") || "",
          hour,
          minute,
          firstTag,
          hasAttachment: false
        };
      } else if (currentTask && line.trim().startsWith("-") && line.includes("	")) {
        currentTask.subItems.push(line.trim().substring(1).trim());
      } else if (currentTask && !line.trim().startsWith("-") && line.trim() !== "") {
        if (currentTask) {
          this.finalizeTask(currentTask);
          tasks.push(currentTask);
          currentTask = null;
        }
      }
    }
    if (currentTask) {
      this.finalizeTask(currentTask);
      tasks.push(currentTask);
    }
    return tasks;
  }
  finalizeTask(task) {
    task.hasAttachment = this.hasImageAttachment(task.content);
    if (!task.hasAttachment) {
      for (const subItem of task.subItems) {
        if (this.hasImageAttachment(subItem)) {
          task.hasAttachment = true;
          break;
        }
      }
    }
  }
};

// types.ts
var DEFAULT_SETTINGS = {
  dailyNotesFolder: "",
  dateFormat: "YYYY-MM-DD",
  defaultRangeMonths: 1,
  tagStyles: [],
  enableGrouping: true,
  minSpacingPixels: 25,
  maxGroupSpanPixels: 60,
  viewMode: "month",
  customStartDate: "",
  customEndDate: "",
  lastQuickRangePreset: "custom"
};

// codeblock-config.ts
var CodeblockConfigParser = class {
  parseConfig(source) {
    const lines = source.trim().split("\n");
    const config = {};
    for (const line of lines) {
      const trimmedLine = line.trim();
      if (!trimmedLine || trimmedLine.startsWith("#")) continue;
      const colonIndex = trimmedLine.indexOf(":");
      if (colonIndex === -1) continue;
      const key = trimmedLine.substring(0, colonIndex).trim();
      const value = trimmedLine.substring(colonIndex + 1).trim();
      switch (key) {
        case "mode":
          if (value === "month" || value === "custom") {
            config.mode = value;
          } else {
            return { error: `Invalid mode: "${value}". Must be "month" or "custom".` };
          }
          break;
        case "startDate":
          config.startDate = value;
          break;
        case "endDate":
          config.endDate = value;
          break;
        case "show":
          config.show = this.parseQuickRangePreset(value);
          if (!config.show) {
            return { error: `Invalid show preset: "${value}". Valid options: last-7, last-30, this-week, this-month, last-3m.` };
          }
          break;
      }
    }
    if (!config.mode) {
      return { error: 'Missing required parameter: "mode". Must specify "month" or "custom".' };
    }
    if (config.mode === "month" && config.startDate) {
      const parsedDate = this.parseDate(config.startDate);
      if (!parsedDate) {
        return { error: `Invalid startDate format: "${config.startDate}". Expected format: DD.MM.YYYY or YYYY-MM-DD.` };
      }
    }
    if (config.mode === "custom") {
      if (config.show) {
        if (config.startDate || config.endDate) {
          return { error: 'Cannot use "show" preset with explicit startDate/endDate. Use either "show" or explicit dates, not both.' };
        }
      } else {
        if (!config.startDate || !config.endDate) {
          return { error: 'Custom mode requires either "show" preset or both "startDate" and "endDate".' };
        }
        const start = this.parseDate(config.startDate);
        const end = this.parseDate(config.endDate);
        if (!start) {
          return { error: `Invalid startDate format: "${config.startDate}". Expected format: DD.MM.YYYY or YYYY-MM-DD.` };
        }
        if (!end) {
          return { error: `Invalid endDate format: "${config.endDate}". Expected format: DD.MM.YYYY or YYYY-MM-DD.` };
        }
        if (end < start) {
          return { error: `endDate (${config.endDate}) must be after or equal to startDate (${config.startDate}).` };
        }
        const daysDiff = Math.ceil((end.getTime() - start.getTime()) / (1e3 * 60 * 60 * 24));
        if (daysDiff > 365) {
          return { error: `Date range cannot exceed 365 days. Current range: ${daysDiff} days.` };
        }
      }
    }
    return config;
  }
  parseQuickRangePreset(value) {
    const presetMap = {
      "last-7": "last7days",
      "last-30": "last30days",
      "this-week": "thisweek",
      "this-month": "thismonth",
      "last-3m": "last3months"
    };
    return presetMap[value] || null;
  }
  parseDate(dateStr) {
    if (dateStr.includes(".")) {
      const parts = dateStr.split(".");
      if (parts.length === 3) {
        const day = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10);
        const year = parseInt(parts[2], 10);
        if (!isNaN(day) && !isNaN(month) && !isNaN(year)) {
          return new Date(year, month - 1, day);
        }
      }
    } else if (dateStr.includes("-")) {
      const parts = dateStr.split("-");
      if (parts.length === 3) {
        const year = parseInt(parts[0], 10);
        const month = parseInt(parts[1], 10);
        const day = parseInt(parts[2], 10);
        if (!isNaN(year) && !isNaN(month) && !isNaN(day)) {
          return new Date(year, month - 1, day);
        }
      }
    }
    return null;
  }
  calculateDateRange(config) {
    if (config.mode === "month") {
      if (config.startDate) {
        const date = this.parseDate(config.startDate);
        if (date) {
          const startDate3 = new Date(date.getFullYear(), date.getMonth(), 1);
          const endDate3 = new Date(date.getFullYear(), date.getMonth() + 1, 0);
          return { startDate: startDate3, endDate: endDate3 };
        }
      }
      const now = /* @__PURE__ */ new Date();
      const startDate2 = new Date(now.getFullYear(), now.getMonth(), 1);
      const endDate2 = new Date(now.getFullYear(), now.getMonth() + 1, 0);
      return { startDate: startDate2, endDate: endDate2 };
    }
    if (config.show) {
      return this.calculateQuickRangePreset(config.show);
    }
    const startDate = this.parseDate(config.startDate);
    const endDate = this.parseDate(config.endDate);
    return { startDate, endDate };
  }
  calculateQuickRangePreset(preset) {
    const now = /* @__PURE__ */ new Date();
    now.setHours(0, 0, 0, 0);
    let startDate;
    let endDate;
    switch (preset) {
      case "last7days":
        endDate = new Date(now);
        startDate = new Date(now);
        startDate.setDate(startDate.getDate() - 6);
        break;
      case "last30days":
        endDate = new Date(now);
        startDate = new Date(now);
        startDate.setDate(startDate.getDate() - 29);
        break;
      case "thisweek":
        const dayOfWeek = now.getDay();
        startDate = new Date(now);
        startDate.setDate(startDate.getDate() - dayOfWeek);
        endDate = new Date(startDate);
        endDate.setDate(endDate.getDate() + 6);
        break;
      case "thismonth":
        startDate = new Date(now.getFullYear(), now.getMonth(), 1);
        endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
        break;
      case "last3months":
        endDate = new Date(now);
        startDate = new Date(now);
        startDate.setMonth(startDate.getMonth() - 3);
        break;
      default:
        startDate = new Date(now.getFullYear(), now.getMonth(), 1);
        endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
    }
    return { startDate, endDate };
  }
};

// embedded-timeline.ts
var ZOOM_CONFIG2 = {
  MIN: 0.7,
  MAX: 10,
  DEFAULT: 1,
  STEP: 0.5,
  BASE_SEGMENT_WIDTH: 200
};
var EmbeddedTimeline = class {
  constructor(plugin, container, config) {
    __publicField(this, "plugin");
    __publicField(this, "container");
    __publicField(this, "config");
    __publicField(this, "initialStartDate");
    __publicField(this, "initialEndDate");
    __publicField(this, "currentStartDate");
    __publicField(this, "currentEndDate");
    __publicField(this, "zoomLevel", ZOOM_CONFIG2.DEFAULT);
    __publicField(this, "tooltips", []);
    __publicField(this, "timelineContainerEl", null);
    __publicField(this, "isDragging", false);
    __publicField(this, "dragStartX", 0);
    __publicField(this, "dragStartScrollLeft", 0);
    __publicField(this, "zoomSlider", null);
    __publicField(this, "zoomLabel", null);
    __publicField(this, "configParser");
    __publicField(this, "currentViewMode", "custom");
    __publicField(this, "monthSelectEl", null);
    __publicField(this, "quickSelectEl", null);
    __publicField(this, "customStartDateInputEl", null);
    __publicField(this, "customEndDateInputEl", null);
    __publicField(this, "viewModeContainerEl", null);
    this.plugin = plugin;
    this.container = container;
    this.config = config;
    this.configParser = new CodeblockConfigParser();
    const dateRange = this.configParser.calculateDateRange(config);
    this.initialStartDate = dateRange.startDate;
    this.initialEndDate = dateRange.endDate;
    this.currentStartDate = new Date(this.initialStartDate);
    this.currentEndDate = new Date(this.initialEndDate);
  }
  async render() {
    this.container.empty();
    this.container.addClass("embedded-timeline-container");
    await this.renderControls();
    await this.renderTimeline();
  }
  destroy() {
    this.cleanupTooltips();
    this.container.empty();
  }
  cleanupTooltips() {
    for (const tooltip of this.tooltips) {
      tooltip.remove();
    }
    this.tooltips = [];
  }
  async renderControls() {
    const controlsDiv = this.container.createDiv({ cls: "embedded-timeline-controls" });
    const topRow = controlsDiv.createDiv({ cls: "embedded-timeline-controls-row" });
    const bottomRow = controlsDiv.createDiv({ cls: "embedded-timeline-controls-row" });
    const navGroup = topRow.createDiv({ cls: "embedded-timeline-nav-group" });
    const prevButton = navGroup.createEl("button", {
      text: "\u2190",
      cls: "mod-cta embedded-timeline-btn-compact",
      attr: { "aria-label": "Previous" }
    });
    prevButton.addEventListener("click", async () => {
      await this.navigatePrevious();
    });
    const todayButton = navGroup.createEl("button", {
      text: "Today",
      cls: "mod-cta embedded-timeline-btn-compact"
    });
    todayButton.addEventListener("click", async () => {
      await this.navigateToToday();
    });
    const nextButton = navGroup.createEl("button", {
      text: "\u2192",
      cls: "mod-cta embedded-timeline-btn-compact",
      attr: { "aria-label": "Next" }
    });
    nextButton.addEventListener("click", async () => {
      await this.navigateNext();
    });
    this.renderZoomControls(topRow);
    const resetButton = topRow.createEl("button", {
      text: "Reset",
      cls: "mod-warning embedded-timeline-btn-compact"
    });
    resetButton.addEventListener("click", async () => {
      await this.resetToInitial();
    });
    this.renderViewModeSelector(bottomRow);
  }
  formatDateDisplay(date) {
    return date.toLocaleDateString("en-US", {
      month: "short",
      day: "numeric",
      year: "numeric"
    });
  }
  formatDateForInput(date) {
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, "0");
    const day = String(date.getDate()).padStart(2, "0");
    return `${year}-${month}-${day}`;
  }
  async renderViewModeSelector(container) {
    const viewModeContainer = container.createDiv({ cls: "embedded-timeline-view-mode" });
    this.viewModeContainerEl = viewModeContainer;
    const modeSelect = viewModeContainer.createEl("select", { cls: "embedded-timeline-select-compact" });
    modeSelect.createEl("option", { value: "month", text: "Month" });
    modeSelect.createEl("option", { value: "custom", text: "Custom" });
    modeSelect.value = this.currentViewMode;
    modeSelect.addEventListener("change", async () => {
      this.currentViewMode = modeSelect.value;
      this.updateViewModeControls();
    });
    const monthContainer = viewModeContainer.createDiv({ cls: "embedded-timeline-month-picker" });
    const monthSelect = monthContainer.createEl("select", { cls: "embedded-timeline-select-compact" });
    this.monthSelectEl = monthSelect;
    await this.populateMonthSelect(monthSelect);
    monthSelect.addEventListener("change", async () => {
      const [year, month] = monthSelect.value.split("-").map(Number);
      this.currentStartDate = new Date(year, month, 1);
      this.currentEndDate = new Date(year, month + 1, 0);
      this.zoomLevel = ZOOM_CONFIG2.DEFAULT;
      await this.renderTimeline();
      this.updateZoomSlider();
    });
    const customContainer = viewModeContainer.createDiv({ cls: "embedded-timeline-custom-picker" });
    const quickSelect = customContainer.createEl("select", { cls: "embedded-timeline-select-compact" });
    this.quickSelectEl = quickSelect;
    quickSelect.createEl("option", { value: "custom", text: "Custom dates" });
    quickSelect.createEl("option", { value: "last7days", text: "Last 7 days" });
    quickSelect.createEl("option", { value: "last30days", text: "Last 30 days" });
    quickSelect.createEl("option", { value: "thisweek", text: "This week" });
    quickSelect.createEl("option", { value: "thismonth", text: "This month" });
    quickSelect.createEl("option", { value: "last3months", text: "Last 3 months" });
    quickSelect.value = "custom";
    quickSelect.addEventListener("change", async () => {
      const preset = quickSelect.value;
      if (preset !== "custom") {
        this.applyQuickRangePreset(preset);
      }
    });
    const datePickersContainer = customContainer.createDiv({ cls: "embedded-timeline-date-pickers" });
    const startDateInput = datePickersContainer.createEl("input", {
      type: "date",
      cls: "embedded-timeline-date-input-compact"
    });
    this.customStartDateInputEl = startDateInput;
    startDateInput.value = this.formatDateForInput(this.currentStartDate);
    const separator = datePickersContainer.createSpan({ cls: "embedded-timeline-date-separator", text: "\u2014" });
    const endDateInput = datePickersContainer.createEl("input", {
      type: "date",
      cls: "embedded-timeline-date-input-compact"
    });
    this.customEndDateInputEl = endDateInput;
    endDateInput.value = this.formatDateForInput(this.currentEndDate);
    startDateInput.addEventListener("change", async () => {
      await this.handleCustomDateChange();
    });
    endDateInput.addEventListener("change", async () => {
      await this.handleCustomDateChange();
    });
    this.updateViewModeControls();
  }
  async handleCustomDateChange() {
    if (!this.customStartDateInputEl || !this.customEndDateInputEl) return;
    const startDateStr = this.customStartDateInputEl.value;
    const endDateStr = this.customEndDateInputEl.value;
    if (!startDateStr || !endDateStr) return;
    const newStartDate = new Date(startDateStr);
    const newEndDate = new Date(endDateStr);
    if (newEndDate < newStartDate) {
      this.customStartDateInputEl.value = this.formatDateForInput(this.currentStartDate);
      this.customEndDateInputEl.value = this.formatDateForInput(this.currentEndDate);
      return;
    }
    const daysDiff = Math.ceil((newEndDate.getTime() - newStartDate.getTime()) / (1e3 * 60 * 60 * 24));
    if (daysDiff > 365) {
      this.customStartDateInputEl.value = this.formatDateForInput(this.currentStartDate);
      this.customEndDateInputEl.value = this.formatDateForInput(this.currentEndDate);
      return;
    }
    this.currentStartDate = newStartDate;
    this.currentEndDate = newEndDate;
    if (this.quickSelectEl) {
      this.quickSelectEl.value = "custom";
    }
    this.zoomLevel = ZOOM_CONFIG2.DEFAULT;
    await this.renderTimeline();
    this.updateZoomSlider();
  }
  applyQuickRangePreset(preset) {
    const now = /* @__PURE__ */ new Date();
    now.setHours(0, 0, 0, 0);
    let startDate;
    let endDate;
    switch (preset) {
      case "last7days":
        endDate = new Date(now);
        startDate = new Date(now);
        startDate.setDate(startDate.getDate() - 6);
        break;
      case "last30days":
        endDate = new Date(now);
        startDate = new Date(now);
        startDate.setDate(startDate.getDate() - 29);
        break;
      case "thisweek":
        const dayOfWeek = now.getDay();
        startDate = new Date(now);
        startDate.setDate(startDate.getDate() - dayOfWeek);
        endDate = new Date(startDate);
        endDate.setDate(endDate.getDate() + 6);
        break;
      case "thismonth":
        startDate = new Date(now.getFullYear(), now.getMonth(), 1);
        endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
        break;
      case "last3months":
        endDate = new Date(now);
        startDate = new Date(now);
        startDate.setMonth(startDate.getMonth() - 3);
        break;
      default:
        return;
    }
    this.currentStartDate = startDate;
    this.currentEndDate = endDate;
    if (this.customStartDateInputEl && this.customEndDateInputEl) {
      this.customStartDateInputEl.value = this.formatDateForInput(startDate);
      this.customEndDateInputEl.value = this.formatDateForInput(endDate);
    }
    this.zoomLevel = ZOOM_CONFIG2.DEFAULT;
    this.renderTimeline();
    this.updateZoomSlider();
  }
  updateViewModeControls() {
    if (!this.monthSelectEl || !this.customStartDateInputEl || !this.customEndDateInputEl) return;
    const monthContainer = this.monthSelectEl.parentElement;
    const customContainer = this.customStartDateInputEl.parentElement;
    if (this.currentViewMode === "month") {
      if (monthContainer) monthContainer.style.display = "flex";
      if (customContainer) customContainer.style.display = "none";
    } else {
      if (monthContainer) monthContainer.style.display = "none";
      if (customContainer) customContainer.style.display = "flex";
    }
  }
  async populateMonthSelect(select) {
    const availableMonths = await this.plugin.parser.getAvailableMonths(
      this.plugin.settings.dailyNotesFolder,
      this.plugin.settings.dateFormat
    );
    select.empty();
    for (const monthKey of availableMonths) {
      const [year, month] = monthKey.split("-").map(Number);
      const date = new Date(year, month, 1);
      const option = select.createEl("option");
      option.value = monthKey;
      option.text = date.toLocaleDateString("en-US", {
        year: "numeric",
        month: "short"
      });
      if (year === this.currentStartDate.getFullYear() && month === this.currentStartDate.getMonth()) {
        option.selected = true;
      }
    }
  }
  renderZoomControls(container) {
    const zoomContainer = container.createDiv({ cls: "embedded-timeline-zoom-controls" });
    const zoomOutIcon = zoomContainer.createDiv({
      cls: "embedded-timeline-zoom-icon",
      attr: { "aria-label": "Zoom out" }
    });
    zoomOutIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.35-4.35"></path><line x1="8" y1="11" x2="14" y2="11"></line></svg>';
    zoomOutIcon.addEventListener("click", () => {
      const newZoom = Math.max(ZOOM_CONFIG2.MIN, this.zoomLevel - ZOOM_CONFIG2.STEP);
      this.applyZoom(newZoom);
    });
    const zoomSlider = zoomContainer.createEl("input", {
      type: "range",
      cls: "embedded-timeline-zoom-slider"
    });
    zoomSlider.min = String(ZOOM_CONFIG2.MIN * 100);
    zoomSlider.max = String(ZOOM_CONFIG2.MAX * 100);
    zoomSlider.value = String(this.zoomLevel * 100);
    zoomSlider.step = String(ZOOM_CONFIG2.STEP * 100);
    const zoomLabel = zoomContainer.createDiv({ cls: "embedded-timeline-zoom-label" });
    zoomLabel.setText(`${Math.round(this.zoomLevel * 100)}%`);
    const zoomInIcon = zoomContainer.createDiv({
      cls: "embedded-timeline-zoom-icon",
      attr: { "aria-label": "Zoom in" }
    });
    zoomInIcon.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="11" cy="11" r="8"></circle><path d="m21 21-4.35-4.35"></path><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>';
    zoomInIcon.addEventListener("click", () => {
      const newZoom = Math.min(ZOOM_CONFIG2.MAX, this.zoomLevel + ZOOM_CONFIG2.STEP);
      this.applyZoom(newZoom);
    });
    zoomSlider.addEventListener("input", () => {
      const newZoomLevel = parseFloat(zoomSlider.value) / 100;
      zoomLabel.setText(`${Math.round(newZoomLevel * 100)}%`);
    });
    zoomSlider.addEventListener("change", () => {
      const newZoomLevel = parseFloat(zoomSlider.value) / 100;
      this.applyZoom(newZoomLevel);
    });
    this.zoomSlider = zoomSlider;
    this.zoomLabel = zoomLabel;
  }
  updateZoomSlider() {
    if (this.zoomSlider) {
      this.zoomSlider.value = String(this.zoomLevel * 100);
    }
    if (this.zoomLabel) {
      this.zoomLabel.setText(`${Math.round(this.zoomLevel * 100)}%`);
    }
  }
  applyZoom(newZoomLevel, anchorX) {
    if (!this.timelineContainerEl) return;
    const scrollContainer = this.timelineContainerEl;
    const scrollLeft = scrollContainer.scrollLeft;
    const containerWidth = scrollContainer.clientWidth;
    const scrollWidth = scrollContainer.scrollWidth;
    let contentAnchorX;
    if (anchorX !== void 0) {
      contentAnchorX = scrollLeft + anchorX;
    } else {
      contentAnchorX = scrollLeft + containerWidth / 2;
    }
    const anchorRatio = contentAnchorX / scrollWidth;
    this.zoomLevel = newZoomLevel;
    this.updateZoomSlider();
    this.renderTimeline().then(() => {
      if (!this.timelineContainerEl) return;
      const newScrollWidth = this.timelineContainerEl.scrollWidth;
      const newContentAnchorX = anchorRatio * newScrollWidth;
      const newScrollLeft = anchorX !== void 0 ? newContentAnchorX - anchorX : newContentAnchorX - containerWidth / 2;
      this.timelineContainerEl.scrollLeft = Math.max(0, newScrollLeft);
    });
  }
  getRangeDurationInDays() {
    const diffTime = Math.abs(this.currentEndDate.getTime() - this.currentStartDate.getTime());
    return Math.ceil(diffTime / (1e3 * 60 * 60 * 24)) + 1;
  }
  async navigatePrevious() {
    const rangeDuration = this.getRangeDurationInDays();
    this.currentStartDate.setDate(this.currentStartDate.getDate() - rangeDuration);
    this.currentEndDate.setDate(this.currentEndDate.getDate() - rangeDuration);
    this.zoomLevel = ZOOM_CONFIG2.DEFAULT;
    await this.render();
  }
  async navigateNext() {
    const rangeDuration = this.getRangeDurationInDays();
    this.currentStartDate.setDate(this.currentStartDate.getDate() + rangeDuration);
    this.currentEndDate.setDate(this.currentEndDate.getDate() + rangeDuration);
    this.zoomLevel = ZOOM_CONFIG2.DEFAULT;
    await this.render();
  }
  async navigateToToday() {
    const now = /* @__PURE__ */ new Date();
    this.currentStartDate = new Date(now.getFullYear(), now.getMonth(), 1);
    this.currentEndDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
    this.zoomLevel = ZOOM_CONFIG2.DEFAULT;
    await this.render();
  }
  async resetToInitial() {
    this.currentStartDate = new Date(this.initialStartDate);
    this.currentEndDate = new Date(this.initialEndDate);
    this.zoomLevel = ZOOM_CONFIG2.DEFAULT;
    await this.render();
  }
  async renderTimeline() {
    this.cleanupTooltips();
    const existingTimeline = this.container.querySelector(".embedded-timeline-scroll");
    if (existingTimeline) {
      existingTimeline.remove();
    }
    const timelineScroll = this.container.createDiv({
      cls: "embedded-timeline-scroll"
    });
    const dailyNotes = await this.plugin.parser.parseDailyNotes(
      this.plugin.settings.dailyNotesFolder,
      this.plugin.settings.dateFormat,
      this.currentStartDate,
      this.currentEndDate
    );
    if (dailyNotes.length === 0) {
      timelineScroll.createDiv({
        cls: "timeline-empty",
        text: "No daily notes found in this date range"
      });
      return;
    }
    await this.renderContinuousTimeline(timelineScroll, dailyNotes);
  }
  async renderContinuousTimeline(container, dailyNotes) {
    const timelineContainer = container.createDiv({ cls: "timeline-continuous" });
    this.timelineContainerEl = timelineContainer;
    this.setupTimelineInteractions(timelineContainer);
    const timelineTrack = timelineContainer.createDiv({ cls: "timeline-track-continuous" });
    const segmentWidth = ZOOM_CONFIG2.BASE_SEGMENT_WIDTH * this.zoomLevel;
    const totalWidth = segmentWidth * dailyNotes.length;
    timelineTrack.style.width = `${totalWidth}px`;
    for (let i = 0; i < dailyNotes.length; i++) {
      const note = dailyNotes[i];
      await this.renderDaySegment(timelineTrack, note, i, dailyNotes.length, segmentWidth);
    }
  }
  setupTimelineInteractions(timelineContainer) {
    timelineContainer.addEventListener("wheel", (e) => {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        const rect = timelineContainer.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const delta = -e.deltaY;
        const zoomFactor = delta > 0 ? ZOOM_CONFIG2.STEP : -ZOOM_CONFIG2.STEP;
        const newZoom = Math.max(
          ZOOM_CONFIG2.MIN,
          Math.min(ZOOM_CONFIG2.MAX, this.zoomLevel + zoomFactor)
        );
        this.applyZoom(newZoom, mouseX);
      } else {
        e.preventDefault();
        timelineContainer.scrollLeft += e.deltaY;
      }
    });
    timelineContainer.addEventListener("mousedown", (e) => {
      if (e.button !== 0) return;
      const target = e.target;
      if (target.closest(".timeline-task") || target.closest("a")) {
        return;
      }
      e.preventDefault();
      this.isDragging = true;
      this.dragStartX = e.clientX;
      this.dragStartScrollLeft = timelineContainer.scrollLeft;
      timelineContainer.style.cursor = "grabbing";
      timelineContainer.style.userSelect = "none";
    });
    const handleMouseMove = (e) => {
      if (!this.isDragging || !this.timelineContainerEl) return;
      e.preventDefault();
      const deltaX = e.clientX - this.dragStartX;
      this.timelineContainerEl.scrollLeft = this.dragStartScrollLeft - deltaX;
    };
    const handleMouseUp = () => {
      if (this.isDragging && this.timelineContainerEl) {
        this.isDragging = false;
        this.timelineContainerEl.style.cursor = "grab";
        this.timelineContainerEl.style.userSelect = "";
      }
    };
    document.addEventListener("mousemove", handleMouseMove);
    document.addEventListener("mouseup", handleMouseUp);
    timelineContainer.addEventListener("mouseleave", () => {
      if (this.isDragging && this.timelineContainerEl) {
        this.isDragging = false;
        this.timelineContainerEl.style.cursor = "grab";
        this.timelineContainerEl.style.userSelect = "";
      }
    });
  }
  groupOverlappingTasks(tasks, segmentWidth) {
    if (tasks.length === 0) return [];
    if (!this.plugin.settings.enableGrouping) {
      return tasks;
    }
    const sortedTasks = [...tasks].sort((a, b) => {
      const aMinutes = a.hour * 60 + a.minute;
      const bMinutes = b.hour * 60 + b.minute;
      return aMinutes - bMinutes;
    });
    const MIN_SPACING_PIXELS = this.plugin.settings.minSpacingPixels;
    const MAX_GROUP_SPAN_PIXELS = this.plugin.settings.maxGroupSpanPixels;
    const groups = [];
    let currentGroup = [sortedTasks[0]];
    for (let i = 1; i < sortedTasks.length; i++) {
      const prevTask = sortedTasks[i - 1];
      const currTask = sortedTasks[i];
      const prevPercentage = (prevTask.hour * 60 + prevTask.minute) / (24 * 60) * 100;
      const currPercentage = (currTask.hour * 60 + currTask.minute) / (24 * 60) * 100;
      const pixelDiff = Math.abs(currPercentage - prevPercentage) * (segmentWidth / 100);
      const firstTaskPercentage = (currentGroup[0].hour * 60 + currentGroup[0].minute) / (24 * 60) * 100;
      const groupSpan = Math.abs(currPercentage - firstTaskPercentage) * (segmentWidth / 100);
      if (pixelDiff < MIN_SPACING_PIXELS && groupSpan < MAX_GROUP_SPAN_PIXELS) {
        currentGroup.push(currTask);
      } else {
        if (currentGroup.length > 1) {
          const avgMinutes = currentGroup.reduce((sum, t) => sum + (t.hour * 60 + t.minute), 0) / currentGroup.length;
          const avgPercentage = avgMinutes / (24 * 60) * 100;
          const avgHour = Math.floor(avgMinutes / 60);
          const avgMinute = Math.floor(avgMinutes % 60);
          groups.push({
            tasks: currentGroup,
            position: avgPercentage,
            averageTime: `${String(avgHour).padStart(2, "0")}:${String(avgMinute).padStart(2, "0")}`
          });
        } else {
          groups.push(currentGroup[0]);
        }
        currentGroup = [currTask];
      }
    }
    if (currentGroup.length > 1) {
      const avgMinutes = currentGroup.reduce((sum, t) => sum + (t.hour * 60 + t.minute), 0) / currentGroup.length;
      const avgPercentage = avgMinutes / (24 * 60) * 100;
      const avgHour = Math.floor(avgMinutes / 60);
      const avgMinute = Math.floor(avgMinutes % 60);
      groups.push({
        tasks: currentGroup,
        position: avgPercentage,
        averageTime: `${String(avgHour).padStart(2, "0")}:${String(avgMinute).padStart(2, "0")}`
      });
    } else {
      groups.push(currentGroup[0]);
    }
    return groups;
  }
  async renderDaySegment(track, note, index, total, segmentWidth) {
    const segment = track.createDiv({ cls: "timeline-segment" });
    segment.style.width = `${segmentWidth}px`;
    segment.style.left = `${segmentWidth * index}px`;
    if (note.tasks.length === 0) {
      segment.addClass("timeline-segment-empty");
    }
    const dateObj = new Date(note.date);
    const dateLabel = segment.createDiv({ cls: "timeline-segment-date" });
    dateLabel.setText(
      dateObj.toLocaleDateString("en-US", {
        month: "short",
        day: "numeric"
      })
    );
    if (note.path) {
      dateLabel.addClass("timeline-segment-date-clickable");
      dateLabel.addEventListener("click", async (e) => {
        e.preventDefault();
        const file = this.plugin.app.vault.getAbstractFileByPath(note.path);
        if (file) {
          await this.plugin.app.workspace.getLeaf(false).openFile(file);
        }
      });
    }
    const weekdayLabel = segment.createDiv({ cls: "timeline-segment-weekday" });
    weekdayLabel.setText(
      dateObj.toLocaleDateString("en-US", {
        weekday: "short"
      })
    );
    const startLabel = segment.createDiv({ cls: "timeline-segment-time timeline-segment-time-start" });
    startLabel.setText("00:00");
    const endLabel = segment.createDiv({ cls: "timeline-segment-time timeline-segment-time-end" });
    endLabel.setText("23:59");
    const groupedItems = this.groupOverlappingTasks(note.tasks, segmentWidth);
    for (const item of groupedItems) {
      if ("tasks" in item) {
        await this.renderGroupedTaskInSegment(segment, item);
      } else {
        await this.renderTaskInSegment(segment, item);
      }
    }
  }
  getTagStyle(tag) {
    if (!tag) return null;
    return this.plugin.settings.tagStyles.find((style) => style.tag === tag);
  }
  async renderGroupedTaskInSegment(segment, groupedTask) {
    const taskDotContainer = segment.createDiv({ cls: "timeline-task-dot-container timeline-task-grouped" });
    const clampedPosition = Math.min(groupedTask.position, 96);
    taskDotContainer.style.left = `${clampedPosition}%`;
    const taskDot = taskDotContainer.createDiv({ cls: "timeline-task-dot" });
    taskDot.setAttribute("data-status", "grouped");
    const countBadge = taskDot.createDiv({ cls: "timeline-task-count-badge" });
    countBadge.setText(String(groupedTask.tasks.length));
    const emojiContainer = taskDotContainer.createDiv({ cls: "timeline-emoji-stack" });
    const emojiSet = /* @__PURE__ */ new Set();
    for (const task of groupedTask.tasks) {
      const tagStyle = this.getTagStyle(task.firstTag);
      if (tagStyle && tagStyle.emoji) {
        emojiSet.add(tagStyle.emoji);
      } else if (task.hasAttachment && !emojiSet.has("\u{1F4F8}")) {
        emojiSet.add("\u{1F4F8}");
      }
    }
    emojiSet.forEach((emoji) => {
      const emojiEl = emojiContainer.createDiv({ cls: "timeline-task-emoji" });
      emojiEl.setText(emoji);
    });
    const tooltip = document.body.createDiv({ cls: "timeline-tooltip" });
    this.tooltips.push(tooltip);
    const tooltipWrapper = tooltip.createDiv({ cls: "timeline-tooltip-wrapper" });
    for (let i = 0; i < groupedTask.tasks.length; i++) {
      const task = groupedTask.tasks[i];
      const tooltipContent = tooltipWrapper.createDiv({ cls: "timeline-tooltip-content" });
      if (i > 0) {
        tooltipContent.addClass("timeline-tooltip-stacked");
      }
      const timeHeader = tooltipContent.createDiv({ cls: "timeline-tooltip-time" });
      const taskTagStyle = this.getTagStyle(task.firstTag);
      if (taskTagStyle && taskTagStyle.emoji) {
        const emojiSpan = timeHeader.createSpan({ cls: "timeline-tooltip-time-emoji" });
        emojiSpan.setText(taskTagStyle.emoji);
      }
      const timeText = timeHeader.createSpan();
      timeText.setText(task.time);
      const taskText = tooltipContent.createDiv({ cls: "timeline-tooltip-task" });
      taskText.textContent = `[${task.status}] `;
      await this.renderTaskContent(taskText, task.content);
      if (task.subItems.length > 0) {
        const subList = tooltipContent.createEl("ul", { cls: "timeline-tooltip-subitems" });
        for (const subItem of task.subItems) {
          const listItem = subList.createEl("li");
          await this.renderTaskContent(listItem, subItem);
        }
      }
    }
    taskDotContainer.addEventListener("mouseenter", () => {
      const rect = taskDotContainer.getBoundingClientRect();
      const viewportHeight = window.innerHeight;
      const tooltipEstimatedHeight = groupedTask.tasks.length * 120;
      let tooltipTop = rect.bottom + 12;
      let tooltipLeft = rect.left + rect.width / 2;
      let transform = "translateX(-50%)";
      let isAbove = false;
      if (tooltipTop + tooltipEstimatedHeight > viewportHeight - 20) {
        const availableHeight = viewportHeight - tooltipTop - 20;
        if (availableHeight < 200) {
          tooltipTop = rect.top - Math.min(tooltipEstimatedHeight, viewportHeight * 0.6) - 12;
          isAbove = true;
          if (tooltipTop < 20) {
            tooltipTop = 20;
          }
        }
      }
      const maxHeight = Math.min(viewportHeight * 0.7, tooltipEstimatedHeight);
      tooltipWrapper.style.maxHeight = `${maxHeight}px`;
      if (isAbove) {
        tooltip.addClass("tooltip-above");
      } else {
        tooltip.removeClass("tooltip-above");
      }
      tooltip.style.top = `${tooltipTop}px`;
      tooltip.style.left = `${tooltipLeft}px`;
      tooltip.style.transform = transform;
      tooltip.addClass("is-visible");
      taskDotContainer.addClass("is-hovered");
    });
    taskDotContainer.addEventListener("mouseleave", () => {
      tooltip.removeClass("is-visible");
      tooltip.removeClass("tooltip-above");
      taskDotContainer.removeClass("is-hovered");
    });
    tooltip.addEventListener("mouseenter", () => {
      tooltip.addClass("is-visible");
      taskDotContainer.addClass("is-hovered");
    });
    tooltip.addEventListener("mouseleave", () => {
      tooltip.removeClass("is-visible");
      tooltip.removeClass("tooltip-above");
      taskDotContainer.removeClass("is-hovered");
    });
  }
  async renderTaskInSegment(segment, task) {
    const totalMinutes = task.hour * 60 + task.minute;
    let percentage = totalMinutes / (24 * 60) * 100;
    percentage = Math.min(percentage, 96);
    const taskDotContainer = segment.createDiv({ cls: "timeline-task-dot-container" });
    taskDotContainer.style.left = `${percentage}%`;
    const taskDot = taskDotContainer.createDiv({ cls: "timeline-task-dot" });
    taskDot.setAttribute("data-status", task.status);
    const tagStyle = this.getTagStyle(task.firstTag);
    if (tagStyle && tagStyle.color) {
      taskDot.addClass("timeline-task-dot-custom");
      taskDot.style.setProperty("background-color", tagStyle.color, "important");
    }
    const taskLabel = taskDot.createDiv({ cls: "timeline-task-label" });
    taskLabel.setText(task.time);
    const emojiContainer = taskDotContainer.createDiv({ cls: "timeline-emoji-stack" });
    if (tagStyle && tagStyle.emoji) {
      const emojiEl = emojiContainer.createDiv({ cls: "timeline-task-emoji" });
      emojiEl.setText(tagStyle.emoji);
    } else if (task.hasAttachment) {
      const emojiEl = emojiContainer.createDiv({ cls: "timeline-task-emoji" });
      emojiEl.setText("\u{1F4F8}");
    }
    const tooltip = document.body.createDiv({ cls: "timeline-tooltip" });
    this.tooltips.push(tooltip);
    const tooltipContent = tooltip.createDiv({ cls: "timeline-tooltip-content" });
    const timeHeader = tooltipContent.createDiv({ cls: "timeline-tooltip-time" });
    if (tagStyle && tagStyle.emoji) {
      const emojiSpan = timeHeader.createSpan({ cls: "timeline-tooltip-time-emoji" });
      emojiSpan.setText(tagStyle.emoji);
    }
    const timeText = timeHeader.createSpan();
    timeText.setText(task.time);
    const taskText = tooltipContent.createDiv({ cls: "timeline-tooltip-task" });
    taskText.textContent = `[${task.status}] `;
    await this.renderTaskContent(taskText, task.content);
    if (task.subItems.length > 0) {
      const subList = tooltipContent.createEl("ul", { cls: "timeline-tooltip-subitems" });
      for (const subItem of task.subItems) {
        const listItem = subList.createEl("li");
        await this.renderTaskContent(listItem, subItem);
      }
    }
    taskDotContainer.addEventListener("mouseenter", () => {
      const rect = taskDotContainer.getBoundingClientRect();
      const viewportHeight = window.innerHeight;
      let tooltipTop = rect.bottom + 12;
      setTimeout(() => {
        const tooltipHeight = tooltip.offsetHeight;
        if (tooltipTop + tooltipHeight > viewportHeight - 20) {
          tooltipTop = rect.top - tooltipHeight - 12;
          tooltip.addClass("tooltip-above");
          if (tooltipTop < 20) {
            tooltipTop = 20;
          }
        } else {
          tooltip.removeClass("tooltip-above");
        }
        tooltip.style.top = `${tooltipTop}px`;
      }, 0);
      tooltip.style.top = `${tooltipTop}px`;
      tooltip.style.left = `${rect.left + rect.width / 2}px`;
      tooltip.style.transform = "translateX(-50%)";
      tooltip.addClass("is-visible");
      taskDotContainer.addClass("is-hovered");
    });
    taskDotContainer.addEventListener("mouseleave", () => {
      tooltip.removeClass("is-visible");
      tooltip.removeClass("tooltip-above");
      taskDotContainer.removeClass("is-hovered");
    });
    tooltip.addEventListener("mouseenter", () => {
      tooltip.addClass("is-visible");
      taskDotContainer.addClass("is-hovered");
    });
    tooltip.addEventListener("mouseleave", () => {
      tooltip.removeClass("is-visible");
      tooltip.removeClass("tooltip-above");
      taskDotContainer.removeClass("is-hovered");
    });
  }
  async renderTaskContent(container, content) {
    const combinedRegex = /(!\[\[([^\]]+)\]\])|(\[\[([^\]]+)\]\])/g;
    let lastIndex = 0;
    let match;
    while ((match = combinedRegex.exec(content)) !== null) {
      if (match.index > lastIndex) {
        await this.renderTextWithLinks(container, content.substring(lastIndex, match.index));
      }
      if (match[1]) {
        const imageName = match[2];
        await this.renderImage(container, imageName);
      } else if (match[3]) {
        const linkText = match[4];
        this.renderLink(container, linkText);
      }
      lastIndex = match.index + match[0].length;
    }
    if (lastIndex < content.length) {
      await this.renderTextWithLinks(container, content.substring(lastIndex));
    }
  }
  async renderTextWithLinks(container, text) {
    const tagRegex = /#([\p{L}\p{N}_\/-]+)/gu;
    let lastIndex = 0;
    let match;
    while ((match = tagRegex.exec(text)) !== null) {
      if (match.index > lastIndex) {
        const textSpan = container.createSpan();
        textSpan.textContent = text.substring(lastIndex, match.index);
      }
      const tagText = match[1];
      const tagLink = container.createEl("a", {
        cls: "tag timeline-tooltip-tag",
        href: "#"
      });
      tagLink.textContent = `#${tagText}`;
      tagLink.addEventListener("click", async (e) => {
        var _a;
        e.preventDefault();
        (_a = this.plugin.app.internalPlugins.getPluginById("global-search")) == null ? void 0 : _a.instance.openGlobalSearch(`tag:#${tagText}`);
      });
      lastIndex = match.index + match[0].length;
    }
    if (lastIndex < text.length) {
      const textSpan = container.createSpan();
      textSpan.textContent = text.substring(lastIndex);
    }
  }
  renderLink(container, linkText) {
    const pipeSplit = linkText.split("|");
    const actualLink = pipeSplit[0].trim();
    const displayText = pipeSplit.length > 1 ? pipeSplit[1].trim() : actualLink;
    const link = container.createEl("a", {
      cls: "internal-link timeline-tooltip-link",
      href: "#"
    });
    link.textContent = displayText;
    link.addEventListener("click", async (e) => {
      e.preventDefault();
      const file = this.plugin.app.metadataCache.getFirstLinkpathDest(actualLink, "");
      if (file) {
        await this.plugin.app.workspace.getLeaf(false).openFile(file);
      }
    });
  }
  async renderImage(container, imageName) {
    const imageFile = this.plugin.app.vault.getAbstractFileByPath(imageName);
    if (imageFile && imageFile instanceof this.plugin.app.vault.adapter.constructor) {
      const imageContainer = container.createDiv({ cls: "timeline-tooltip-image" });
      const img = imageContainer.createEl("img");
      const resourcePath = this.plugin.app.vault.getResourcePath(imageFile);
      img.src = resourcePath;
      img.alt = imageName;
    } else {
      const files = this.plugin.app.vault.getFiles();
      const matchedFile = files.find((f) => f.name === imageName || f.path.endsWith(imageName));
      if (matchedFile) {
        const imageContainer = container.createDiv({ cls: "timeline-tooltip-image" });
        const img = imageContainer.createEl("img");
        const resourcePath = this.plugin.app.vault.getResourcePath(matchedFile);
        img.src = resourcePath;
        img.alt = imageName;
      }
    }
  }
};

// main.ts
var DailyNotesTimelinePlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "settings");
    __publicField(this, "parser");
    __publicField(this, "embeddedTimelines", /* @__PURE__ */ new Map());
  }
  async onload() {
    await this.loadSettings();
    this.parser = new DailyNotesParser(this.app.vault);
    this.registerView(
      VIEW_TYPE_TIMELINE,
      (leaf) => new TimelineView(leaf, this)
    );
    this.addRibbonIcon("calendar-clock", "Open Daily Notes Timeline", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-timeline-view",
      name: "Open Daily Notes Timeline",
      callback: () => {
        this.activateView();
      }
    });
    this.addSettingTab(new TimelineSettingTab(this.app, this));
    this.registerMarkdownCodeBlockProcessor(
      "daily-timeline",
      this.processTimelineCodeblock.bind(this)
    );
  }
  async processTimelineCodeblock(source, el, ctx) {
    const parser = new CodeblockConfigParser();
    const result = parser.parseConfig(source);
    if ("error" in result) {
      el.createDiv({
        cls: "embedded-timeline-error",
        text: `\u26A0\uFE0F Timeline Configuration Error: ${result.error}`
      });
      return;
    }
    const existingTimeline = this.embeddedTimelines.get(el);
    if (existingTimeline) {
      existingTimeline.destroy();
      this.embeddedTimelines.delete(el);
    }
    const embeddedTimeline = new EmbeddedTimeline(this, el, result);
    this.embeddedTimelines.set(el, embeddedTimeline);
    try {
      await embeddedTimeline.render();
    } catch (error) {
      el.createDiv({
        cls: "embedded-timeline-error",
        text: `\u26A0\uFE0F Failed to render timeline: ${error.message}`
      });
    }
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(VIEW_TYPE_TIMELINE)[0];
    if (!leaf) {
      leaf = workspace.getLeaf(true);
      await leaf.setViewState({
        type: VIEW_TYPE_TIMELINE,
        active: true
      });
    }
    workspace.revealLeaf(leaf);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onunload() {
    this.app.workspace.detachLeavesOfType(VIEW_TYPE_TIMELINE);
    for (const timeline of this.embeddedTimelines.values()) {
      timeline.destroy();
    }
    this.embeddedTimelines.clear();
  }
};
